"""
Unit tests for comprehensive error handling
------------------------------------------
Tests for error handling, exception cases, and edge conditions.
"""

import os
import tempfile
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from config import ServerConfig, _get_default_video_directory
from streaming_server import VideoStreamingServer


class TestConfigErrorHandling:
    """Test cases for configuration error handling"""

    def test_get_default_video_directory_fallback(self):
        """Test default video directory fallback when home is unavailable"""
        with patch("pathlib.Path.home", side_effect=RuntimeError("No home")):
            result = _get_default_video_directory()
            assert result == "./videos"

    def test_get_default_video_directory_success(self):
        """Test default video directory when home is available"""
        with patch("pathlib.Path.home") as mock_home:
            mock_home.return_value = Path("/home/user")
            result = _get_default_video_directory()
            # Convert to forward slashes for cross-platform compatibility
            expected = str(Path("/home/user/Videos")).replace("\\", "/")
            actual = str(result).replace("\\", "/")
            assert actual == expected

    def test_config_invalid_port_edge_cases(self):
        """Test config validation with edge case ports"""
        with tempfile.TemporaryDirectory() as temp_dir:
            # Test port 0 (invalid)
            with patch.dict(
                os.environ,
                {
                    "VIDEO_SERVER_PORT": "0",
                    "VIDEO_SERVER_PASSWORD_HASH": "test_hash",
                    "VIDEO_SERVER_DIRECTORY": temp_dir,
                },
            ):
                with pytest.raises(
                    ValueError, match="Port must be between 1 and 65535"
                ):
                    ServerConfig()

            # Test port 65536 (invalid)
            with patch.dict(
                os.environ,
                {
                    "VIDEO_SERVER_PORT": "65536",
                    "VIDEO_SERVER_PASSWORD_HASH": "test_hash",
                    "VIDEO_SERVER_DIRECTORY": temp_dir,
                },
            ):
                with pytest.raises(
                    ValueError, match="Port must be between 1 and 65535"
                ):
                    ServerConfig()

    def test_config_invalid_log_max_bytes(self):
        """Test config with invalid log max bytes"""
        with tempfile.TemporaryDirectory() as temp_dir:
            with patch.dict(
                os.environ,
                {
                    "VIDEO_SERVER_LOG_MAX_BYTES": "invalid",
                    "VIDEO_SERVER_PASSWORD_HASH": "test_hash",
                    "VIDEO_SERVER_DIRECTORY": temp_dir,
                },
            ):
                # Should handle invalid int conversion gracefully
                try:
                    config = ServerConfig()
                    # Should fall back to default
                    assert config.log_max_bytes == 10485760  # 10MB default
                except ValueError:
                    # Or raise appropriate error
                    pass


class TestServerErrorHandling:
    """Test cases for server error handling"""

    def test_server_missing_video_directory(self, test_config):
        """Test server behavior when video directory is missing"""
        test_config.video_directory = "/nonexistent/directory"

        with pytest.raises(ValueError, match="does not exist"):
            server = VideoStreamingServer(test_config)
            server.run()

    def test_server_permission_denied_directory(self, test_config):
        """Test server behavior with permission denied directory"""
        # This test would need specific platform handling
        # Skipping for now as it requires admin privileges
        pass

    def test_server_video_directory_is_file(self, test_config, tmp_path):
        """Test server behavior when video directory is actually a file"""
        fake_dir = tmp_path / "not_a_directory.txt"
        fake_dir.write_text("This is a file, not a directory")

        test_config.video_directory = str(fake_dir)

        # Should raise an error or handle gracefully
        with pytest.raises((ValueError, OSError)):
            server = VideoStreamingServer(test_config)
            server.run()


class TestRequestErrorHandling:
    """Test cases for request error handling"""

    def test_malformed_authorization_header(self, test_server):
        """Test handling of malformed authorization headers"""
        with test_server.app.test_client() as client:
            # Test completely malformed header
            response = client.get("/", headers={"Authorization": "Malformed"})
            assert response.status_code == 401

            # Test missing credentials
            response = client.get("/", headers={"Authorization": "Basic"})
            assert response.status_code == 401

            # Test invalid base64
            response = client.get("/", headers={"Authorization": "Basic invalid!"})
            assert response.status_code == 401

    def test_extremely_long_path(self, authenticated_client):
        """Test handling of extremely long file paths"""
        long_path = "a" * 5000  # Very long path
        response = authenticated_client.get(f"/stream/{long_path}")

        # Should handle gracefully, either 404, 414 (URI Too Long), or other error
        assert response.status_code in [400, 404, 414, 500]

    def test_null_bytes_in_path(self, authenticated_client):
        """Test handling of null bytes in file paths"""
        malicious_path = "test\x00.mp4"
        response = authenticated_client.get(f"/stream/{malicious_path}")

        # Should handle gracefully
        assert response.status_code in [400, 403, 404]

    def test_unicode_in_path(self, authenticated_client):
        """Test handling of unicode characters in paths"""
        unicode_path = "test_файл.mp4"  # Cyrillic characters
        response = authenticated_client.get(f"/stream/{unicode_path}")

        # Should handle gracefully (404 is fine since file doesn't exist)
        assert response.status_code in [200, 404, 400]


class TestLoggingErrorHandling:
    """Test cases for logging error handling"""

    def test_logging_disk_full_simulation(self, test_config, tmp_path):
        """Test logging behavior when disk is full"""
        from logging_config import SecurityEventLogger

        test_config.log_directory = str(tmp_path)
        logger = SecurityEventLogger(test_config)

        # Simulate disk full by mocking file operations
        with patch("builtins.open", side_effect=OSError("No space left on device")):
            try:
                logger.log_auth_attempt("user", True, "127.0.0.1")
                # Should handle gracefully without crashing
            except OSError:
                # Or may re-raise the error appropriately
                pass

    def test_logging_permission_error(self, test_config):
        """Test logging behavior with permission errors"""
        from logging_config import SecurityEventLogger

        # Try to write to a directory we don't have permission to
        test_config.log_directory = "/root/logs"  # Typically not writable

        try:
            logger = SecurityEventLogger(test_config)
            logger.log_auth_attempt("user", True, "127.0.0.1")
        except PermissionError:
            # Should handle appropriately
            pass
        except Exception:
            # Or other appropriate error handling
            pass


class TestMemoryErrorHandling:
    """Test cases for memory-related error handling"""

    def test_large_file_listing(self, authenticated_client, temp_video_dir):
        """Test server behavior with very large directory listings"""
        # Create many files to test memory usage
        for i in range(1000):
            (temp_video_dir / f"video_{i:04d}.mp4").write_text("fake content")

        response = authenticated_client.get("/")

        # Should handle large directories without running out of memory
        assert response.status_code in [
            200,
            500,
        ]  # 500 acceptable if server limits directory size

    def test_very_large_file_access(self, authenticated_client, temp_video_dir):
        """Test accessing metadata of very large files"""
        # Create a test file entry (don't actually create large file)
        large_file = temp_video_dir / "large_file.mp4"
        large_file.write_text("content")

        # Mock the file to appear very large
        with patch.object(Path, "stat") as mock_stat:
            mock_stat.return_value.st_size = 10 * 1024**3  # 10GB
            mock_stat.return_value.st_mtime = 1640995200  # Fixed timestamp

            response = authenticated_client.get("/")
            # Should handle large file metadata gracefully
            assert response.status_code in [200, 500]


class TestNetworkErrorHandling:
    """Test cases for network-related error handling"""

    def test_slow_client_connection(self, test_server):
        """Test handling of slow client connections"""
        # This would require more sophisticated network testing
        # For now, just test that server doesn't crash with normal requests
        with test_server.app.test_client() as client:
            response = client.get("/health")
            assert response.status_code == 200

    def test_client_disconnect_during_streaming(self, authenticated_client):
        """Test handling of client disconnect during file streaming"""
        # Create a test file
        response = authenticated_client.get("/stream/test_video.mp4")
        # Should handle gracefully even if client disconnects
        assert response.status_code in [200, 404]


class TestFileSystemErrorHandling:
    """Test cases for file system error handling"""

    def test_file_deleted_during_access(self, authenticated_client, temp_video_dir):
        """Test handling when file is deleted between directory listing and access"""
        test_file = temp_video_dir / "test.mp4"
        test_file.write_text("content")

        # File exists for directory listing but gets deleted before streaming
        with patch("pathlib.Path.is_file") as mock_is_file:
            # First call (during initial check) returns True, second returns False
            mock_is_file.side_effect = [True, False]

            response = authenticated_client.get("/stream/test.mp4")
            assert response.status_code in [404, 500]

    def test_file_permissions_changed(self, authenticated_client, temp_video_dir):
        """Test handling when file permissions are changed during access"""
        test_file = temp_video_dir / "test.mp4"
        test_file.write_text("content")

        # Mock permission error during file access
        with patch(
            "flask.send_from_directory",
            side_effect=PermissionError("Permission denied"),
        ):
            response = authenticated_client.get("/stream/test.mp4")
            assert response.status_code in [403, 500]
